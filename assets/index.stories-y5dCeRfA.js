import{r as l}from"./index-CTzypqlY.js";import{g as E}from"./group-CTbjIu5X.js";import{f as h,G as C,b as A,w as b,m as M,$ as O,n as D,o as N,X as V,Y as B}from"./withSize-Bqu-aQP_.js";import{w as j}from"./withOHLCData-BEr55ucm.js";import{d as q}from"./discontinuousTimeScaleProvider-DjLVsG-0.js";import"./index-kspPnZk0.js";import"./jsx-runtime-D_zvdyIk.js";function X(d,a){let r;if(a===void 0)for(const t of d)t!=null&&(r<t||r===void 0&&t>=t)&&(r=t);else{let t=-1;for(let n of d)(n=a(n,++t,d))!=null&&(r<n||r===void 0&&n>=n)&&(r=n)}return r}class x extends l.Component{render(){const{className:a,strokeStyle:r,strokeWidth:t,fillStyle:n,point:c,r:s}=this.props,i=h(s)(c.datum);return l.createElement("circle",{className:a,cx:c.x,cy:c.y,stroke:r,strokeWidth:t,fill:n,r:i})}}x.defaultProps={fillStyle:"#4682B4",className:"react-financial-charts-marker-circle"};x.drawOnCanvas=(d,a,r)=>{const{strokeStyle:t,fillStyle:n,r:c,strokeWidth:s}=d;t!==void 0&&(r.strokeStyle=t),s!==void 0&&(r.lineWidth=s),n!==void 0&&(r.fillStyle=n);const{datum:i,x:m,y:o}=a,e=h(c)(i);r.moveTo(m,o),r.beginPath(),r.arc(m,o,e,0,2*Math.PI,!1),r.fill(),t!==void 0&&r.stroke()};let I=class extends l.Component{constructor(){super(...arguments),this.drawOnCanvas=(a,r)=>{const t=this.getMarkers(r),{markerProps:n}=this.props;E(t,s=>s.fillStyle,s=>s.strokeStyle).forEach((s,i)=>{i!=="none"&&(a.fillStyle=i),s.forEach(m=>{m.forEach(o=>{const{marker:e}=o;e.drawOnCanvas(Object.assign(Object.assign(Object.assign({},e.defaultProps),n),{fillStyle:i}),o,a)})})})},this.getMarkers=a=>{const{yAccessor:r,markerProvider:t,markerProps:n}=this.props,{xAccessor:c,xScale:s,chartConfig:{yScale:i},plotData:m}=a;let{marker:o}=this.props;if(!(t||o))throw new Error("required prop, either marker or markerProvider missing");return m.map(e=>{const p=r(e);if(p===void 0)return;const y=c(e);t&&(o=t(e));const u=Object.assign(Object.assign({},o.defaultProps),n),S=h(u.fillStyle),f=h(u.strokeStyle);return{x:s(y),y:i(p),fillStyle:S(e),strokeStyle:f(e),datum:e,marker:o}}).filter(e=>e!==void 0).map(e=>e)}}render(){return l.createElement(C,{canvasDraw:this.drawOnCanvas,canvasToDraw:A,drawOn:["pan"]})}};class g extends l.Component{constructor(){super(...arguments),this.drawOnCanvas=(a,r)=>{const t=this.getMarkers(r),{markerProps:n}=this.props;E(t,s=>s.fillStyle,s=>s.strokeStyle).forEach((s,i)=>{i!=="none"&&(a.fillStyle=i),s.forEach(m=>{m.forEach(o=>{const{marker:e}=o;e.drawOnCanvas({...e.defaultProps,...n,fillStyle:i},o,a)})})})},this.getMarkers=a=>{const{yAccessor:r,markerProvider:t,markerProps:n}=this.props,{xAccessor:c,xScale:s,chartConfig:{yScale:i},plotData:m}=a;let{marker:o}=this.props;if(!(t||o))throw new Error("required prop, either marker or markerProvider missing");return m.map(e=>{const p=r(e);if(p===void 0)return;const y=c(e);t&&(o=t(e));const u={...o.defaultProps,...n},S=h(u.fillStyle),f=h(u.strokeStyle);return{x:s(y),y:i(p),fillStyle:S(e),strokeStyle:f(e),datum:e,marker:o}}).filter(e=>e!==void 0).map(e=>e)}}render(){return l.createElement(C,{canvasDraw:this.drawOnCanvas,canvasToDraw:A,drawOn:["pan"]})}}try{g.displayName="ScatterSeries",g.__docgenInfo={description:"",displayName:"ScatterSeries",props:{marker:{defaultValue:null,description:"A Marker to draw.",name:"marker",required:!1,type:{name:"any"}},markerProvider:{defaultValue:null,description:"Given the data point return a Marker.",name:"markerProvider",required:!1,type:{name:"((datum: any) => any) | undefined"}},markerProps:{defaultValue:null,description:"Props to pass to the marker.",name:"markerProps",required:!1,type:{name:"object | undefined"}},yAccessor:{defaultValue:null,description:"Accessor for y value.",name:"yAccessor",required:!0,type:{name:"(data: any) => number | undefined"}}}}}catch{}class v extends l.Component{constructor(){super(...arguments),this.margin={left:0,right:40,top:0,bottom:24},this.xScaleProvider=q().inputDateAccessor(a=>a.date),this.yAccessor=a=>a.close,this.yExtents=a=>[a.high,a.low]}render(){const{data:a,height:r,ratio:t,width:n}=this.props,{data:c,xScale:s,xAccessor:i,displayXAccessor:m}=this.xScaleProvider(a),o=i(c[c.length-1]),p=[i(c[Math.max(0,c.length-100)]),o],y=X(c,f=>f.volume),u=O().range([1,40]).domain([0,y]),S=f=>u(f.volume);return l.createElement(D,{height:r,ratio:t,width:n,margin:this.margin,data:c,displayXAccessor:m,seriesName:"Data",xScale:s,xAccessor:i,xExtents:p},l.createElement(N,{id:1,yExtents:this.yExtents},l.createElement(I,{yAccessor:this.yAccessor,marker:x,markerProps:{r:S}}),l.createElement(V,null),l.createElement(B,null)))}}const T=j("MINUTES")(b()(M()(v)));try{v.displayName="BasicScatterSeries",v.__docgenInfo={description:"",displayName:"BasicScatterSeries",props:{}}}catch{}try{componentDidMount.displayName="componentDidMount",componentDidMount.__docgenInfo={description:"Called immediately after a component is mounted. Setting state here will trigger re-rendering.",displayName:"componentDidMount",props:{}}}catch{}const U={component:g,title:"Visualization/Series/Scatter"},k=()=>l.createElement(T,null);var _,w,P;k.parameters={...k.parameters,docs:{...(_=k.parameters)==null?void 0:_.docs,source:{originalSource:"() => <BasicScatterSeries />",...(P=(w=k.parameters)==null?void 0:w.docs)==null?void 0:P.source}}};const F=["bubble"];export{F as __namedExportsOrder,k as bubble,U as default};
